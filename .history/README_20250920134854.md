# Unsafe File Scanner - A Linux Security Tool (Python Version)

[![Python Version](https://img.shields.io/badge/python-3.8%2B-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)

## Abstract

This project develops a command-line utility called **Unsafe File Scanner**, written in Python, to enhance Linux system security by detecting files with unsafe permissions, such as world-writable files, SUID/SGID binaries, and files writable by non-owners. The tool recursively scans directories using Python's `os` and `stat` modules and applies bitwise operations to evaluate file risks. It leverages core Operating System concepts—file system structure, permission models, UID/GID, and access controls—to provide accurate security inspection. Designed to be lightweight and extensible, it can be integrated into security audits. Future improvements may include real-time monitoring with inotify (using Python's watchdog module), detailed reporting, and customizable scanning rules.

**Keywords:** Linux Security, File Permissions, SUID/SGID, World-Writable Files, Privilege Escalation, File System Audit, Python Programming, OS Security, Insecure Configurations, Security Tool.

## Introduction

Security is a critical aspect of every computer system. Linux is widely used in servers, cloud platforms, and software development because of its robust permission model and system design. In Linux, file permissions define who can read, write, or execute a file. Incorrectly configured permissions can create serious security risks, such as world-writable files, SUID/SGID binaries, or files writable by non-owners, potentially allowing attackers to gain unauthorized access or escalate privileges.

This project, **Unsafe File Scanner**, is a command-line tool developed in Python to detect unsafe files. The tool scans directories recursively, evaluates file permissions using Python's `os.stat()` and bitwise operations on permission bits, and identifies files that may be insecure.

By applying Operating System concepts such as file system hierarchy, user/group IDs (UID/GID), and access controls, the tool is efficient, lightweight, and suitable for real-world Linux security audits. System administrators, security analysts, and DevSecOps teams can use it to quickly locate and remediate permission-related risks.

Future enhancements include real-time monitoring, detailed security reports, and customizable scanning rules, allowing adaptation to diverse organizational security policies. This project demonstrates the intersection of Python programming, OS knowledge, and cybersecurity practice.

## Objectives

- **Detect unsafe files** – Identify world-writable files, SUID/SGID binaries, and files writable by non-owners.
- **Enhance Linux security** – Provide administrators and security teams with actionable insights to reduce privilege escalation risks.
- **Leverage OS concepts** – Apply file system structure, permission models, and UID/GID concepts in Python.
- **Lightweight and efficient scanning** – Use Python modules (`os`, `stat`) for recursive scanning without significant system overhead.
- **Future extensibility** – Prepare for features such as real-time monitoring, detailed reports, and customizable scanning rules.

## Features

### Core Security Checks
- **SUID Detection**: Identifies files with Set User ID bit set
- **SGID Detection**: Identifies files with Set Group ID bit set  
- **World-Writable Files**: Finds files writable by all users
- **Non-Owner Writable**: Detects files writable by groups or others but not owners
- **Permission Anomalies**: Identifies unusual permission combinations

### Advanced Features
- **Recursive Directory Scanning**: Scans entire directory trees
- **Configurable Exclusions**: Skip specific directories and file patterns
- **Risk Level Assessment**: Categorizes findings as HIGH, MEDIUM, or LOW risk
- **Comprehensive Reporting**: JSON output with detailed statistics
- **Logging Support**: Configurable logging levels and output
- **Performance Optimized**: Efficient scanning with file size limits

### Command-Line Interface
- **Flexible Arguments**: Multiple directory support
- **Configuration Files**: JSON-based configuration
- **Output Options**: Console and file output
- **Verbose Mode**: Detailed scan information
- **Exit Codes**: Proper exit codes for automation

## Installation

### Prerequisites
- Python 3.8 or higher
- Linux/Unix operating system
- Root or appropriate permissions for scanning system directories

### Quick Install
```bash
# Clone the repository
git clone https://github.com/example/unsafe-file-scanner.git
cd unsafe-file-scanner

# Install dependencies
pip install -r requirements.txt

# Make executable
chmod +x unsafe_file_scanner.py

# Run the scanner
python unsafe_file_scanner.py /etc /bin /usr/bin
```

### Install as Package
```bash
# Install in development mode
pip install -e .

# Or install directly
pip install .
```

## Usage

### Basic Usage
```bash
# Scan specific directories
python unsafe_file_scanner.py /etc /bin /usr/bin

# Scan with verbose output
python unsafe_file_scanner.py --verbose /home/user

# Save results to file
python unsafe_file_scanner.py --output scan_report.json /var
```

### Advanced Usage
```bash
# Use custom configuration
python unsafe_file_scanner.py --config my_config.json /etc

# Set log level
python unsafe_file_scanner.py --log-level DEBUG /tmp

# Scan with all options
python unsafe_file_scanner.py --config config.json --output report.json --verbose --log-level INFO /etc /bin /usr/bin
```

### Command-Line Options
```
positional arguments:
  directories           Directories to scan for unsafe files

optional arguments:
  -h, --help            show this help message and exit
  --config CONFIG, -c CONFIG
                        Configuration file path
  --output OUTPUT, -o OUTPUT
                        Output file for scan report (JSON format)
  --verbose, -v         Enable verbose output
  --log-level {DEBUG,INFO,WARNING,ERROR}
                        Set logging level
```

## Configuration

The scanner supports JSON configuration files for customization:

```json
{
  "exclude_dirs": [".git", ".svn", "node_modules", "__pycache__"],
  "exclude_files": [".DS_Store", "Thumbs.db"],
  "max_file_size": 104857600,
  "follow_symlinks": false,
  "log_level": "INFO",
  "output_format": "json",
  "risk_thresholds": {
    "high": ["suid", "sgid", "world_writable"],
    "medium": ["non_owner_writable"],
    "low": ["other_issues"]
  }
}
```

### Configuration Options
- **exclude_dirs**: Directories to skip during scanning
- **exclude_files**: File patterns to ignore
- **max_file_size**: Maximum file size to scan (bytes)
- **follow_symlinks**: Whether to follow symbolic links
- **log_level**: Logging verbosity level
- **risk_thresholds**: Risk level categorization rules

## Output Format

The scanner generates comprehensive JSON reports:

```json
{
  "scan_info": {
    "timestamp": "2024-01-15T10:30:00",
    "scanner_version": "1.0.0",
    "total_files_scanned": 15420,
    "scan_duration_seconds": 12.34
  },
  "statistics": {
    "total_files": 15420,
    "unsafe_files": 23,
    "suid_files": 5,
    "sgid_files": 3,
    "world_writable": 8,
    "non_owner_writable": 12
  },
  "unsafe_files": [
    {
      "path": "/tmp/world_writable_file",
      "permissions": "rw-rw-rw-",
      "owner": "user",
      "group": "user",
      "size": 1024,
      "modified_time": "2024-01-15T09:15:00",
      "issues": ["World-writable"],
      "risk_level": "HIGH"
    }
  ],
  "summary": {
    "total_unsafe_files": 23,
    "high_risk_files": 8,
    "medium_risk_files": 10,
    "low_risk_files": 5
  }
}
```

## Security Checks Explained

### SUID (Set User ID) Files
Files with SUID bit set run with the privileges of the file owner, not the user executing them. This can be dangerous if the file is writable by non-owners.

### SGID (Set Group ID) Files  
Files with SGID bit set run with the privileges of the file's group. Similar security concerns as SUID files.

### World-Writable Files
Files that can be modified by any user on the system. These pose significant security risks as any user can modify them.

### Non-Owner Writable Files
Files writable by groups or others but not by the owner. This can indicate misconfigured permissions.

## Examples

### Example 1: Basic System Scan
```bash
python unsafe_file_scanner.py /etc /bin /usr/bin
```

### Example 2: User Directory Scan with Report
```bash
python unsafe_file_scanner.py --output user_scan.json --verbose /home/user
```

### Example 3: Custom Configuration Scan
```bash
python unsafe_file_scanner.py --config security_config.json /var/log
```

### Example 4: Integration with Scripts
```bash
#!/bin/bash
# Security audit script
python unsafe_file_scanner.py /etc > /var/log/security_audit.log 2>&1
if [ $? -eq 1 ]; then
    echo "Security issues found! Check the log."
    exit 1
fi
```

## Exit Codes

- **0**: No unsafe files found
- **1**: Unsafe files detected
- **130**: Interrupted by user (Ctrl+C)
- **Other**: Error during execution

## Performance Considerations

- **File Size Limits**: Large files are skipped by default (configurable)
- **Directory Exclusions**: Skip common non-security-relevant directories
- **Efficient Walking**: Uses `os.walk()` for optimal directory traversal
- **Memory Management**: Processes files individually to minimize memory usage

## Troubleshooting

### Common Issues

**Permission Denied**
```bash
# Run with appropriate permissions
sudo python unsafe_file_scanner.py /etc
```

**Large File Warnings**
```bash
# Increase file size limit in config
{
  "max_file_size": 1073741824  # 1GB
}
```

**Missing Dependencies**
```bash
# Install required packages
pip install -r requirements.txt
```

## Development

### Running Tests
```bash
# Install test dependencies
pip install pytest pytest-cov

# Run tests
pytest

# Run with coverage
pytest --cov=unsafe_file_scanner
```

### Code Formatting
```bash
# Format code
black unsafe_file_scanner.py

# Check linting
flake8 unsafe_file_scanner.py
```

### Type Checking
```bash
# Run type checker
mypy unsafe_file_scanner.py
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Linux file permission system design
- Python standard library developers
- Security community for best practices
- Open source security tools inspiration

## Future Enhancements

- **Real-time Monitoring**: Integration with `watchdog` for live file system monitoring
- **Web Interface**: Web-based dashboard for scan results
- **Database Storage**: SQLite/PostgreSQL backend for historical data
- **Alert System**: Email/Slack notifications for critical findings
- **Remediation Suggestions**: Automated fix recommendations
- **Integration APIs**: REST API for external tool integration
- **Advanced Filtering**: More sophisticated exclusion rules
- **Performance Metrics**: Detailed timing and resource usage statistics

## Changelog

### Version 1.0.0
- Initial release
- Core security checks (SUID, SGID, world-writable, non-owner writable)
- JSON configuration support
- Comprehensive reporting
- Command-line interface
- Recursive directory scanning
- Risk level assessment
- Logging support

---

**Note**: This tool is designed for security auditing purposes. Always review findings carefully and understand the security implications before making changes to file permissions on production systems.